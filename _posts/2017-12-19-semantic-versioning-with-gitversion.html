---
layout: post
title: Semantic versioning with GitVersion
date: 2017-12-19 21:07:41.000000000 +01:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
tags:
- blog-helm-sample
- GitVersion
- TeamCity
- versioning
meta:
  _thumbnail_id: '3441'
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
  _publicize_job_id: '12689084443'
author:


  display_name: ngeor
  first_name: Nikolaos
  last_name: Georgiou
---
<p>I recently stumbled upon a tool called <a href="https://github.com/GitTools/GitVersion" target="_blank">GitVersion</a> which takes a different approach on versioning. I already mentioned some <a href="https://ngeor.wordpress.com/2017/12/18/on-versioning/" target="_blank">options regarding versioning</a>, but all of them require you to actively specify the version somewhere. GitVersion instead is able to calculate it based on the state of your git repository.</p>
<p><!--more--></p>
<p>This requires some getting used to, but GitVersion is like a pure function that calculates the semantic version of any given commit based on three things:</p>
<ul>
<li>the nearest tag</li>
<li>the commit messages between this commit and the nearest tag</li>
<li>the name of the branch</li>
</ul>
<p>It can be configured with a yaml file and it supports branching models like GitFlow and GitHubFlow. I will only discuss GitHubFlow here. Before going into technical details, I'll show some examples of how GitVersion calculates the semantic version.</p>
<p>Our starting point is the <strong>master branch</strong>, which is already tagged as v1.2.3. If we run GitVersion, it will see we're on a tag, so its job is done. It will report that the semantic version on that commit is 1.2.3.</p>
<p>Let's say that we want to <strong>work on a new ticket</strong>. We branch out of master, which is tagged as v1.2.3. The branch name is BH-42-add-header. We start working and we commit to the branch with a message like "BH-42 adding header for blog-helm project" (always add ticket numbers to your commit messages). GitVersion now needs to traverse history to find the nearest tag, which is 1.2.3. The next version should be 1.2.4, but we're on a feature branch, so GitVersion gives something like <code>1.2.4-BH-42-add-header.1</code>. This is the next version plus the branch name plus the number of commits from the tag.</p>
<p>What if we want to <strong>change the minor or major version</strong>? This is done by adding special text in the commit message (or messages). By default, that's <code>+semver: major</code> for bumping the major version and <code>+semver: minor</code> for the minor version. If we add a new commit with a message like "BH-42 making the header responsive +semver: minor", then GitVersion will report the version <code>1.3.0-BH-42-add-header.1</code>.</p>
<p>What happens if we <strong>merge this feature branch</strong>? Assuming we don't corrupt the commit messages during some rebase/squash/other, everything should be fine. GitVersion will traverse master's history up to the tag 1.2.3 and determine that the version is 1.3.0 (without the branch suffix, as that's only for feature branches).</p>
<p>It's important to <strong>tag</strong> once we have a successful build in the master branch. You're probably doing this already anyway. It makes the life of GitVersion easier, because it has less commits to traverse in order to evaluate the version.</p>
<p>Let's do some hands on work. I'll modify <a href="https://github.com/ngeor/blog-helm" target="_blank">blog-helm</a>, the project I used in the <a href="https://ngeor.wordpress.com/cd-with-helm/" target="_blank">CD with Helm series</a>, to use GitVersion. First, in order to install GitVersion you can use chocolatey (<code>choco install GitVersion.Portable</code>) or brew (<code>brew install gitversion</code>). It is written in .NET so it will pull in mono on your Mac. On TeamCity, I'll be using the Docker image <code>gittools/gitversion</code>.</p>
<p>Once it's installed, we need to configure the repo with <code>gitversion init</code>, which offers a configuration wizard (this is only needs to happen the first time you introduce GitVersion):</p>
<p>[code]<br />
PS [master ≡]&gt; gitversion init<br />
Which would you like to change?</p>
<p>0) Save changes and exit<br />
1) Exit without saving</p>
<p>2) Run getting started wizard</p>
<p>3) Set next version number<br />
4) Branch specific configuration<br />
5) Branch Increment mode (per commit/after tag) (Current: )<br />
6) Assembly versioning scheme (Current: )<br />
7) Setup build scripts</p>
<p>&gt; 2</p>
<p>The way you will use GitVersion will change a lot based on your branching strategy. What branching strategy will you be using:</p>
<p>1) GitFlow (or similar)<br />
2) GitHubFlow<br />
3) Unsure, tell me more</p>
<p>&gt; 2</p>
<p>By default GitVersion will only increment the version when tagged</p>
<p>What do you want the default increment mode to be (can be overriden per branch):</p>
<p>1) Follow SemVer and only increment when a release has been tagged (continuous delivery mode)<br />
2) Increment based on branch config every commit (continuous deployment mode)<br />
3) Skip</p>
<p>&gt; 2</p>
<p>Questions are all done, you can now edit GitVersion's configuration further<br />
Which would you like to change?</p>
<p>0) Save changes and exit<br />
1) Exit without saving</p>
<p>2) Run getting started wizard</p>
<p>3) Set next version number<br />
4) Branch specific configuration<br />
5) Branch Increment mode (per commit/after tag) (Current: ContinuousDeployment)<br />
6) Assembly versioning scheme (Current: )<br />
7) Setup build scripts</p>
<p>&gt; 0<br />
[/code]</p>
<p>This generates a configuration file <code>GitVersion.yml</code> which looks like this:</p>
<p>[code]<br />
mode: ContinuousDeployment<br />
branches: {}<br />
ignore:<br />
  sha: []<br />
[/code]</p>
<p>To evaluate the semantic version, I just run <code>gitversion</code> in the repo. It spits out a large json object:</p>
<p>[code]<br />
C:\Users\ngeor\Projects\GitHub\blog-helm [master ≡ +1 ~0 -0 !]&gt; gitversion<br />
{<br />
  &quot;Major&quot;:1,<br />
  &quot;Minor&quot;:0,<br />
  &quot;Patch&quot;:7,<br />
  &quot;PreReleaseTag&quot;:&quot;ci.6&quot;,<br />
  &quot;PreReleaseTagWithDash&quot;:&quot;-ci.6&quot;,<br />
  &quot;PreReleaseLabel&quot;:&quot;ci&quot;,<br />
  &quot;PreReleaseNumber&quot;:6,<br />
  &quot;BuildMetaData&quot;:&quot;&quot;,<br />
  &quot;BuildMetaDataPadded&quot;:&quot;&quot;,<br />
  &quot;FullBuildMetaData&quot;:&quot;Branch.master.Sha.58e23dbe5d5541a5ff7ce440de57317d1325637c&quot;,<br />
  &quot;MajorMinorPatch&quot;:&quot;1.0.7&quot;,<br />
  &quot;SemVer&quot;:&quot;1.0.7-ci.6&quot;,<br />
  &quot;LegacySemVer&quot;:&quot;1.0.7-ci6&quot;,<br />
  &quot;LegacySemVerPadded&quot;:&quot;1.0.7-ci0006&quot;,<br />
  &quot;AssemblySemVer&quot;:&quot;1.0.7.0&quot;,<br />
  &quot;FullSemVer&quot;:&quot;1.0.7-ci.6&quot;,<br />
  &quot;InformationalVersion&quot;:&quot;1.0.7-ci.6+Branch.master.Sha.58e23dbe5d5541a5ff7ce440de57317d1325637c&quot;,<br />
  &quot;BranchName&quot;:&quot;master&quot;,<br />
  &quot;Sha&quot;:&quot;58e23dbe5d5541a5ff7ce440de57317d1325637c&quot;,<br />
  &quot;NuGetVersionV2&quot;:&quot;1.0.7-ci0006&quot;,<br />
  &quot;NuGetVersion&quot;:&quot;1.0.7-ci0006&quot;,<br />
  &quot;CommitsSinceVersionSource&quot;:6,<br />
  &quot;CommitsSinceVersionSourcePadded&quot;:&quot;0006&quot;,<br />
  &quot;CommitDate&quot;:&quot;2017-12-09&quot;<br />
}<br />
[/code]</p>
<p>But what I really care is to get the SemVer field:</p>
<p>[code]<br />
PS&gt; gitversion /showvariable SemVer<br />
1.0.7-ci.6<br />
[/code]</p>
<p>With the configuration we got from the wizard, the master branch behaves a bit weird when it's not tagged. Non tagged commits in master will have an extra suffix "ci". To fix this, change the <code>GitVersion.yml</code> file into this:</p>
<p>[code]<br />
mode: ContinuousDeployment<br />
continuous-delivery-fallback-tag: ''<br />
branches: {}<br />
ignore:<br />
  sha: []<br />
[/code]</p>
<p>Now the tool spits out the expected values for the master branch, even if it's not tagged yet:</p>
<p>[code]<br />
PS&gt; gitversion /showvariable SemVer<br />
1.0.7<br />
[/code]</p>
<p>There are more configuration options documented <a href="http://gitversion.readthedocs.io/en/stable/configuration/" target="_blank">here</a>.</p>
<p>To use it in TeamCity, I'll rewrite the bash script `version.sh` which used to look like this and relied on <code>package.json</code> to determine the version:</p>
<p>[code language="bash"]<br />
#!/bin/sh</p>
<p>set -x<br />
set -e</p>
<p>GIT_SHA=$(git rev-parse HEAD)<br />
GIT_BRANCH=$(git rev-parse --abbrev-ref HEAD)<br />
APP_VERSION=$(cat package.json  | grep version | cut -d\&quot; -f 4)</p>
<p>if [ &quot;$GIT_BRANCH&quot; = &quot;master&quot; ]; then<br />
  IMAGE_TAG=&quot;$APP_VERSION&quot;<br />
else<br />
  IMAGE_TAG=&quot;$APP_VERSION-$GIT_SHA&quot;<br />
fi</p>
<p>echo &quot;Docker image tag will be $IMAGE_TAG&quot;</p>
<p># store image tag into a text file (artifact for deployment)<br />
echo &quot;$IMAGE_TAG&quot; &gt; image-tag.txt</p>
<p># inject environment variable for next steps<br />
echo &quot;##teamcity[setParameter name='env.IMAGE_TAG' value='$IMAGE_TAG']&quot;</p>
<p>[/code]</p>
<p>into this:</p>
<p>[code language="bash"]<br />
#!/bin/sh</p>
<p>set -e</p>
<p># make sure we have master branch and tags<br />
git fetch --tags origin</p>
<p>GITTOOLS_GITVERSION_TAG=${GITTOOLS_GITVERSION_TAG:-v4.0.0-beta.12}<br />
docker pull gittools/gitversion:$GITTOOLS_GITVERSION_TAG<br />
IMAGE_TAG=$(docker run --rm \<br />
  -u $(id -u):$(id -g) \<br />
  -v /opt/buildagent/system/git:/opt/buildagent/system/git \<br />
  -v $(pwd):/repo \<br />
  gittools/gitversion:$GITTOOLS_GITVERSION_TAG \<br />
  /showvariable SemVer)</p>
<p>echo &quot;Docker image tag will be $IMAGE_TAG&quot;</p>
<p># store image tag into a text file (artifact for deployment)<br />
echo &quot;$IMAGE_TAG&quot; &gt; image-tag.txt</p>
<p># inject environment variable for next steps<br />
echo &quot;##teamcity[setParameter name='env.IMAGE_TAG' value='$IMAGE_TAG']&quot;</p>
<p># set build number of TeamCity (better UX)<br />
echo &quot;##teamcity[buildNumber '$IMAGE_TAG']&quot;<br />
[/code]</p>
<p>The important bit is the <code>docker run</code> command but it has quite some tricks:</p>
<ul>
<li><code>--rm</code> removes the container once the command exits</li>
<li><code>-u $(id -u):$(id -g)</code> runs this as the regular TeamCity user and not root. GitVersion adds some cache files in the current directory, which, if added as root, will prevent TeamCity from cleaning up.</li>
<li><code>-v /opt/buildagent/system/git:/opt/buildagent/system/git</code> seems to be needed otherwise GitVersion dies with (<code>ERROR: error: object directory /opt/buildagent/system/git/git-3566BB37.git/objects does not exist; check .git/objects/info/alternates.</code>). This is specific to TeamCity and actually specific to how TeamCity uses git internally.</li>
<li><code>-v $(pwd):/repo</code> mounts the current directory as the <code>/repo</code> directory inside the Docker container.</li>
<li><code>gittools/gitversion:$GITTOOLS_GITVERSION_TAG</code> is the image we're using.</li>
<li><code>/showvariable SemVer</code> is the parameter we saw earlier, asking GitVersion to simply print the semantic version.</li>
</ul>
<p>The extra <code>git fetch</code> command is a countermeasure for some optimization that TeamCity does, in which case we might not have the master branch available at all. This can confuse GitVersion.</p>
<p>The last bit also overrides the build number of TeamCity, which improves UX because we see the semantic version as the build number:</p>
<p><img src="{{ site.baseurl }}/assets/2017-12-19-20_35_20-blog-helm-__-commit-stage-_-branches-e28094-teamcity.png" alt="2017-12-19 20_35_20-Blog Helm __ Commit Stage _ Branches — TeamCity.png" width="706" height="128" class="alignnone size-full wp-image-3443" /></p>
<p>We can see that consecutive commits change the build number:</p>
<p><img src="{{ site.baseurl }}/assets/2017-12-19-20_41_33-blog-helm-__-commit-stage-_-overview-e28094-teamcity.png" alt="2017-12-19 20_41_33-Blog Helm __ Commit Stage _ Overview — TeamCity.png" width="1034" height="489" class="alignnone size-full wp-image-3444" /></p>
<p>If we re-run a branch, it won't have an effect to its build number. The build number is now derived from the semantic version and the semantic version is calculated solely based on the git history.</p>
<p>We should also have TeamCity tag the master branch automatically:</p>
<p><img src="{{ site.baseurl }}/assets/2017-12-19-19_07_58-commit-stage-configuration-e28094-teamcity.png" alt="2017-12-19 19_07_58-Commit Stage Configuration — TeamCity.png" width="774" height="461" class="alignnone size-full wp-image-3442" /></p>
<p>Now, let's try to create a minor feature. As before, we create a feature branch out of master. But this time, in the commit message we specify the magic string <code>+semver: minor</code>. The version gets adjusted automatically:</p>
<p><img src="{{ site.baseurl }}/assets/2017-12-19-20_59_12-blog-helm-__-commit-stage-_-overview-e28094-teamcity.png" alt="2017-12-19 20_59_12-Blog Helm __ Commit Stage _ Overview — TeamCity.png" width="518" height="167" class="alignnone size-full wp-image-3445" /></p>
<p>When this gets merged, master will get version 1.1.0.</p>
<p>GitVersion offers an interesting approach to versioning. It can be applied to all projects, regardless of technology. It uses native git elements and it can support multiple branching models. The only downside I can think of is that if your repository already has a convention for storing the version (e.g. <code>package.json</code> for nodeJS projects), that might cause surprise and perhaps some confusion.</p>
