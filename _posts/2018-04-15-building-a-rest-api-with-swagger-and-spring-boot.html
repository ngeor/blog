---
layout: post
title: Building a REST API with Swagger and Spring Boot
date: 2018-04-15 09:37:27.000000000 +02:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
tags:
- Java
- maven
- Spring Boot
- swagger
meta:
  _wpcom_is_markdown: '1'
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
  _publicize_job_id: '16813554989'
  timeline_notification: '1523777849'
author:


  display_name: ngeor
  first_name: Nikolaos
  last_name: Georgiou
---
<p>In this post, I'll be using Swagger to build a REST API with Java and Spring Boot. <a href="https://swagger.io/">Swagger</a> is an API framework. It uses a YAML-based language to define an API and it has a code generator that supports multiple languages.</p>
<p><!--more--></p>
<h2>Tooling</h2>
<p>Swagger offers an <a href="https://editor.swagger.io/">online editor</a> which is useful to start playing with the language and get familiar with the syntax. But in order to generate some code, it's handy to have the <a href="https://swagger.io/swagger-codegen/">code generator</a> locally.</p>
<p>On the left side of the editor you can see the YAML syntax. On the right side, a preview of the API, which is updated real-time as you modify the YAML definition:</p>
<p><img src="{{ site.baseurl }}/assets/2018-04-15-09_15_41.png" alt="2018-04-15 09_15_41-.png" width="1887" height="994" class="alignnone size-full wp-image-3762" /></p>
<h2>Blog REST API</h2>
<p>The example REST API will be an API for blogging.</p>
<p>We're gonna have the following operations:</p>
<ul>
<li>POST on /post will create a new blog post</li>
<li>GET on /post will get a list of posts</li>
<li>GET on /post/postId (e.g. /post/42) will get that blog post</li>
<li>POST on /post/postId will update that blog post</li>
<li>DELETE on /post/postId will delete that blog post</li>
<li>POST on /post/{postId}/comment creates a new comment</li>
</ul>
<p>(I hope it's not too confusing that one of the models is called Post, which is also an HTTP verb)</p>
<h2>YAML file</h2>
<p>The entire YAML file looks like this:</p>
<p>[code lang=text]<br />
swagger: &quot;2.0&quot;<br />
info:<br />
  description: &quot;A blog API.&quot;<br />
  version: &quot;1.0.0&quot;<br />
  title: &quot;Blog API&quot;<br />
  license:<br />
    name: &quot;Apache 2.0&quot;<br />
    url: &quot;http://www.apache.org/licenses/LICENSE-2.0.html&quot;</p>
<p>host: &quot;blog.acme.io&quot;<br />
basePath: &quot;/v1&quot;</p>
<p>tags:<br />
- name: &quot;post&quot;<br />
  description: &quot;Managing posts&quot;<br />
- name: &quot;comment&quot;<br />
  description: &quot;Managing comments&quot;</p>
<p>schemes:<br />
- &quot;http&quot;</p>
<p>paths:<br />
  /post:<br />
    get:<br />
      tags:<br />
      - &quot;post&quot;<br />
      summary: &quot;Get most recent posts&quot;<br />
      responses:<br />
        200:<br />
          description: &quot;List of posts&quot;<br />
          schema:<br />
            type: array<br />
            items:<br />
              $ref: &#039;#/definitions/Post&#039;<br />
    post:<br />
      tags:<br />
      - &quot;post&quot;<br />
      summary: &quot;Add a new blog post&quot;<br />
      parameters:<br />
      - in: &quot;body&quot;<br />
        name: &quot;body&quot;<br />
        description: &quot;Blog post information&quot;<br />
        required: true<br />
        schema:<br />
          $ref: &quot;#/definitions/Post&quot;<br />
      responses:<br />
        405:<br />
          description: &quot;Invalid input&quot;<br />
  /post/{postId}:<br />
    get:<br />
      tags:<br />
      - &quot;post&quot;<br />
      summary: &quot;Find blog post by ID&quot;<br />
      description: &quot;Returns a single blog post&quot;<br />
      parameters:<br />
      - name: &quot;postId&quot;<br />
        in: &quot;path&quot;<br />
        description: &quot;ID of post to return&quot;<br />
        required: true<br />
        type: &quot;integer&quot;<br />
        format: &quot;int64&quot;<br />
      responses:<br />
        200:<br />
          description: &quot;successful operation&quot;<br />
          schema:<br />
            $ref: &quot;#/definitions/Post&quot;<br />
        400:<br />
          description: &quot;Invalid ID supplied&quot;<br />
        404:<br />
          description: &quot;Pet not found&quot;<br />
    post:<br />
      tags:<br />
      - &quot;post&quot;<br />
      summary: &quot;Updates a blog post in the store&quot;<br />
      parameters:<br />
      - name: &quot;postId&quot;<br />
        in: &quot;path&quot;<br />
        description: &quot;ID of pet that needs to be updated&quot;<br />
        required: true<br />
        type: &quot;integer&quot;<br />
        format: &quot;int64&quot;<br />
      - in: &quot;body&quot;<br />
        name: &quot;body&quot;<br />
        description: &quot;Blog post information&quot;<br />
        required: true<br />
        schema:<br />
          $ref: &quot;#/definitions/Post&quot;<br />
      responses:<br />
        405:<br />
          description: &quot;Invalid input&quot;<br />
    delete:<br />
      tags:<br />
      - &quot;post&quot;<br />
      summary: &quot;Deletes a blog post&quot;<br />
      parameters:<br />
      - name: &quot;postId&quot;<br />
        in: &quot;path&quot;<br />
        description: &quot;ID of blog post to delete&quot;<br />
        required: true<br />
        type: &quot;integer&quot;<br />
        format: &quot;int64&quot;<br />
      responses:<br />
        400:<br />
          description: &quot;Invalid ID supplied&quot;<br />
        404:<br />
          description: &quot;Blog post not found&quot;<br />
  /post/{postId}/comment:<br />
    post:<br />
      summary: &quot;Create new comment&quot;<br />
      tags:<br />
      - &quot;comment&quot;<br />
      responses:<br />
        404:<br />
          description: &quot;Post not found&quot;<br />
    parameters:<br />
    - name: &quot;postId&quot;<br />
      in: &quot;path&quot;<br />
      required: true<br />
      type: &quot;integer&quot;<br />
      format: &quot;int64&quot;</p>
<p>definitions:<br />
  Post:<br />
    type: &quot;object&quot;<br />
    properties:<br />
      id:<br />
        type: &quot;integer&quot;<br />
        format: &quot;int64&quot;<br />
      title:<br />
        type: &quot;string&quot;<br />
      body:<br />
        type: &quot;string&quot;<br />
      author:<br />
        type: &quot;string&quot;<br />
      createdAt:<br />
        type: &quot;string&quot;<br />
        format: &quot;date-time&quot;<br />
      comments:<br />
        type: &quot;array&quot;<br />
        items:<br />
          $ref: &quot;#/definitions/Comment&quot;<br />
  Comment:<br />
    type: &quot;object&quot;<br />
    properties:<br />
      id:<br />
        type: &quot;integer&quot;<br />
        format: &quot;int64&quot;<br />
      body:<br />
        type: &quot;string&quot;<br />
      author:<br />
        type: &quot;string&quot;<br />
      createdAt:<br />
        type: &quot;string&quot;<br />
        format: &quot;date-time&quot;</p>
<p>[/code]</p>
<p>It takes a while to get familiar with it, so let's highlight some interesting stuff.</p>
<ul>
<li>base path (<code>basePath: "/v1"</code>). That means that the entire API is under the "/v1" path. This can be useful if you want to do a major upgrade in your API in a backwards incompatible way.</li>
<li><strong>tags</strong> are used to logically group related operations together. It only affects the documentation of the API and how it's presented to the user.</li>
<li><strong>paths</strong> is the place where you define your operations. For example, see the operation that creates a new blog post:</li>
</ul>
<p>[code lang=text]<br />
paths:<br />
  /post: # the path is /post<br />
    post: # the HTTP verb is POST<br />
      tags:<br />
      - &quot;post&quot;<br />
      summary: &quot;Add a new blog post&quot;<br />
      parameters:<br />
      - in: &quot;body&quot;<br />
        name: &quot;body&quot;<br />
        description: &quot;Blog post information&quot;<br />
        required: true<br />
        schema:<br />
          $ref: &quot;#/definitions/Post&quot;<br />
      responses:<br />
        405:<br />
          description: &quot;Invalid input&quot;<br />
[/code]</p>
<ul>
<li><strong>definitions</strong> is where you define your models. For example, this is how the blog post model is defined:</li>
</ul>
<p>[code lang=text]<br />
definitions:<br />
  Post:<br />
    type: &quot;object&quot;<br />
    properties:<br />
      id:<br />
        type: &quot;integer&quot;<br />
        format: &quot;int64&quot;<br />
      title:<br />
        type: &quot;string&quot;<br />
      body:<br />
        type: &quot;string&quot;<br />
      author:<br />
        type: &quot;string&quot;<br />
      createdAt:<br />
        type: &quot;string&quot;<br />
        format: &quot;date-time&quot;<br />
      comments:<br />
        type: &quot;array&quot;<br />
        items:<br />
          $ref: &quot;#/definitions/Comment&quot;<br />
[/code]</p>
<p>The best way to get familiar with this is to read the documentation and play with it.</p>
<h2>Generating code</h2>
<p>You can see the latest version of <code>swagger-codegen</code> on the <a href="https://github.com/swagger-api/swagger-codegen/releases">releases page on GitHub</a>, which is 2.3.1 at this time. The jar is not published on GitHub. Here's a direct link to version <a href="https://oss.sonatype.org/content/repositories/releases/io/swagger/swagger-codegen-cli/2.3.1/swagger-codegen-cli-2.3.1.jar">2.3.1</a>. You can find all versions <a href="https://oss.sonatype.org/content/repositories/releases/io/swagger/swagger-codegen-cli/">here</a>. Download that jar and put it in a folder (in my case it lives in <code>C:\opt\swagger</code>).</p>
<p>If you run the code generator without any arguments, you get the list of languages it supports:</p>
<p>[code lang=text]<br />
PS&gt; java -jar C:\opt\swagger\swagger-codegen-cli-2.3.1.jar<br />
Available languages: [ada, ada-server, akka-scala, android, apache2, apex, aspnetcore, bash, csharp, clojure, cwiki, cpprest, csharp-dotnet2, dart, elixir, elm, eiffel, erlang-client, erlang-server, finch, flash, python-flask, go, go-server, groovy, haskell-http-client, haskell, jmeter, jaxrs-cxf-client, jaxrs-cxf, java, inflector, jaxrs-cxf-cdi, jaxrs-spec, jaxrs, msf4j, java-pkmst, java-play-framework, jaxrs-resteasy-eap, jaxrs-resteasy, javascript, javascript-closure-angular, java-vertx, kotlin, lua, lumen, nancyfx, nodejs-server, objc, perl, php, powershell, pistache-server, python, qt5cpp, r, rails5, restbed, ruby, rust, rust-server, scala, scala-lagom-server, scalatra, scalaz, php-silex, sinatra, slim, spring, dynamic-html, html2, html, swagger, swagger-yaml, swift4, swift3, swift, php-symfony, tizen, typescript-aurelia, typescript-angular, typescript-angularjs, typescript-fetch, typescript-jquery, typescript-node, undertow, ze-ph]<br />
[/code]</p>
<p>The language we'll be using is spring.</p>
<p>To see information about how to generate the code, you need to pass <code>help generate</code> as arguments. To see information about a specific language, you need to pass <code>config-help -l</code> e.g. <code>config-help -l spring</code>.</p>
<p>Let's create an empty folder and save the YAML file in there as <code>swagger.yaml</code>. At a very minimum, you need to specify the language (in our case that is spring) and the YAML file:</p>
<p>[code lang=text]<br />
PS&gt; java -jar C:\opt\swagger\swagger-codegen-cli-2.3.1.jar generate -l spring -i .\swagger.yaml<br />
[/code]</p>
<p>This will generate a maven project in the same location (i.e. <code>pom.xml</code> and <code>swagger.yaml</code> will be on the same folder).</p>
<p>By default, the generated code is using Java 7 and a third party library for dates (<a href="http://www.threeten.org/threetenbp/">threetenbp</a>). To use Java 8 and the built-in java.time API, we need to pass an extra flag:</p>
<p>[code lang=text]<br />
PS&gt; java -jar C:\opt\swagger\swagger-codegen-cli-2.3.1.jar generate -l spring -i .\swagger.yaml --additional-properties dateLibrary=java8<br />
[/code]</p>
<p>Some obvious things that you'd want to override are the default group and artifact IDs, as well as the packages of the generated source code:</p>
<p>[code lang=text]<br />
PS&gt; java -jar C:\opt\swagger\swagger-codegen-cli-2.3.1.jar generate -l spring -i .\swagger.yaml --additional-properties dateLibrary=java8,groupId=com.acme,artifactId=blog,basePackage=com.acme.blog,configPackage=com.acme.blog.configuration,apiPackage=com.acme.blog.api,modelPackage=com.acme.blog.model<br />
[/code]</p>
<p>In any case, at this point you've got a ready to run server. Build the package with <code>mvn package</code> and run it with <code>java -jar target/blog-1.0.0.jar</code>. You'll be able to access the server at http://localhost:8080/v1.</p>
<p>Before going any further, I'll upgrade the pom dependencies to use Spring Boot 2 (from 1.5.9 to 2.0.1) and the latest <a href="https://springfox.github.io/springfox/docs/current/">SpringFox</a> (which changes the appearance of the UI a bit, from 2.7.0 to 2.8.0).</p>
<p>This requires a change in <code>application.properties</code> (part of <a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide">breaking changes between Spring Boot 1 and Spring Boot 2</a>):</p>
<p>[code lang=text]<br />
# old style, Spring Boot 1.5.x<br />
server.contextPath=/v1</p>
<p># new style, Spring Boot 2<br />
server.servlet.contextPath=/v1<br />
[/code]</p>
<p><img src="{{ site.baseurl }}/assets/2018-04-15-09_18_44.png" alt="2018-04-15 09_18_44-.png" width="1428" height="998" class="alignnone size-full wp-image-3763" /></p>
<p>Every time you run the code generation tool, it will overwrite the code it had generated previously. Luckily, it offers a way of leaving certain files intact. That's that <code>.swagger-codegen-ignore</code> file, which works just like a <code>.gitignore</code> file. For now, I add the <code>pom.xml</code> and <code>application.properties</code> there:</p>
<p>[code lang=text]<br />
pom.xml<br />
src/**/application.properties<br />
[/code]</p>
<h2>Advantages</h2>
<p>What I like about using swagger is that you get a lot of boilerplate code generated automatically, while it is still just regular Java/Spring code (with some extra Swagger annotations which only affect documentation). This gives you for free a UI which documents your API and offers a playground for people to experiment with it.</p>
