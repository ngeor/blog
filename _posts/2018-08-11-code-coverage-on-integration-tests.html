---
layout: post
title: Code coverage on integration tests?
date: 2018-08-11 19:48:15.000000000 +02:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
tags:
- code coverage
- integration tests
- JaCoCo
- Java
- maven
- unit tests
meta:
  timeline_notification: '1534009696'
  _wpcom_is_markdown: '1'
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
  _publicize_job_id: '20978217934'
author:


  display_name: ngeor
  first_name: Nikolaos
  last_name: Georgiou
---
<p>Should you collect and measure code coverage on integration tests or only unit tests? In this post I'll share some thoughts on this topic.</p>
<p><!--more--></p>
<p>Unit tests are tests which exercise a single unit of code in isolation. In my case, the programming language is Java, so the smallest unit of code is a class. All external dependencies to the class being tested (<em>system under test</em>) should be replaced with test doubles (stubs, mocks).</p>
<p>Integration tests on the other hand exercise multiple units of code together. Again, in my case, the context is Spring Boot. It's very easy to test the entire actual application with Spring Boot.</p>
<p>Going from a unit test to an integration test is not a binary divide but a spectrum. As we broaden the testing boundary, we shift from testing a unit to testing a group. For example, we might have an integration test which focuses on the interaction of the database layer with an actual database, while mocking some other parts. Or, we might have a test which is not using test doubles but its actual dependencies. There is a place for these tests, the only challenge being how to call them.</p>
<p>To keep things simple here, by integration test I mean testing the entire Spring Boot application.</p>
<p>As unit tests operate on a single unit of code, without using real external dependencies, they are typically very fast and they can be - and should be - exhaustive.</p>
<p>Integration tests on the other hand are much slower, but they can test the application under real conditions, test HTTP protocol interaction, etc.</p>
<p>Going back to code coverage, code coverage is nothing more but checking which lines of code were executed during a test run. A single integration test might be hitting a great amount of lines of code, giving a big boost of code coverage. However, as the test is not focusing on little details, it is possible that a unit is slightly modified in an undesired way and the test might still be pass.</p>
<p>As unit tests are cheaper, they allow to write thorough tests for each unit in isolation. That is why it makes more sense to measure code coverage on the unit tests. It is more likely that a line that has been visited (covered) has actually been tested and it hasn't just been visited by coincidence.</p>
<p>The same principle applies to fixing a bug: if it is possible, a bug should be fixed with a unit test.</p>
<p>Is there a reason why you should measure code coverage on integration tests? I think there might be. I've been practicing the following technique:</p>
<ul>
<li>measure code coverage (and code complexity) on unit tests</li>
<li>generate the code coverage report</li>
<li>measure code coverage (but not code complexity) on integration tests</li>
<li>generate the <strong>aggregate</strong> code coverage report, unit and integration tests combined</li>
</ul>
<p>While I don't obsess on how much my code coverage is on the first report, the second report <em>should</em> be nearing 100% code coverage. There is always going to be some code that can't be tested with unit tests and that is <strong>totally fine</strong>. I don't think we should write awkward code to try to unit test code that was not meant to be unit tested. However, if the aggregate code coverage report isn't hitting almost 100% code coverage, then you either have really forgotten to write some tests, or you might have uncovered some code that can be deleted. Nothing better than deleting some unused code.</p>
<p>Now, time for some code. Step by step, this is what my JaCoCo configuration looks like in <code>pom.xml</code>:</p>
<p><code>pre-unit-test</code> starts the JaCoCo agent before the unit tests are run:</p>
<pre><code>        &lt;execution&gt;
          &lt;id&gt;pre-unit-test&lt;/id&gt;
          &lt;goals&gt;
            &lt;goal&gt;prepare-agent&lt;/goal&gt;
          &lt;/goals&gt;
        &lt;/execution&gt;
</code></pre>
<p><code>post-unit-test</code> generates the unit test code coverage report after the unit tests pass:</p>
<pre><code>        &lt;execution&gt;
          &lt;id&gt;post-unit-test&lt;/id&gt;
          &lt;phase&gt;test&lt;/phase&gt;
          &lt;goals&gt;
            &lt;goal&gt;report&lt;/goal&gt;
          &lt;/goals&gt;
        &lt;/execution&gt;
</code></pre>
<p><code>check-unit-test</code> breaks the build if the code coverage is not good enough, according to the configured standards (code complexity is also a reason to break the build):</p>
<pre><code>        &lt;execution&gt;
          &lt;id&gt;check-unit-test&lt;/id&gt;
          &lt;phase&gt;test&lt;/phase&gt;
          &lt;goals&gt;
            &lt;goal&gt;check&lt;/goal&gt;
          &lt;/goals&gt;
          &lt;configuration&gt;
            &lt;dataFile&gt;${project.build.directory}/jacoco.exec&lt;/dataFile&gt;
            &lt;rules&gt;
              &lt;rule&gt;
                &lt;element&gt;BUNDLE&lt;/element&gt;
                &lt;limits&gt;
                  &lt;limit&gt;
                    &lt;counter&gt;INSTRUCTION&lt;/counter&gt;
                    &lt;value&gt;COVEREDRATIO&lt;/value&gt;
                    &lt;minimum&gt;${jacoco.unit-tests.limit.instruction-ratio}&lt;/minimum&gt;
                  &lt;/limit&gt;
                  &lt;limit&gt;
                    &lt;counter&gt;BRANCH&lt;/counter&gt;
                    &lt;value&gt;COVEREDRATIO&lt;/value&gt;
                    &lt;minimum&gt;${jacoco.unit-tests.limit.branch-ratio}&lt;/minimum&gt;
                  &lt;/limit&gt;
                &lt;/limits&gt;
              &lt;/rule&gt;
              &lt;rule&gt;
                &lt;element&gt;CLASS&lt;/element&gt;
                &lt;limits&gt;
                  &lt;limit&gt;
                    &lt;counter&gt;COMPLEXITY&lt;/counter&gt;
                    &lt;value&gt;TOTALCOUNT&lt;/value&gt;
                    &lt;maximum&gt;${jacoco.unit-tests.limit.class-complexity}&lt;/maximum&gt;
                  &lt;/limit&gt;
                &lt;/limits&gt;
              &lt;/rule&gt;
              &lt;rule&gt;
                &lt;element&gt;METHOD&lt;/element&gt;
                &lt;limits&gt;
                  &lt;limit&gt;
                    &lt;counter&gt;COMPLEXITY&lt;/counter&gt;
                    &lt;value&gt;TOTALCOUNT&lt;/value&gt;
                    &lt;maximum&gt;${jacoco.unit-tests.limit.method-complexity}&lt;/maximum&gt;
                  &lt;/limit&gt;
                &lt;/limits&gt;
              &lt;/rule&gt;
            &lt;/rules&gt;
          &lt;/configuration&gt;
        &lt;/execution&gt;
</code></pre>
<p><code>pre-integration-test</code> prepares the JaCoCo agent for the integration tests:</p>
<pre><code>        &lt;execution&gt;
          &lt;id&gt;pre-integration-test&lt;/id&gt;
          &lt;goals&gt;
            &lt;goal&gt;prepare-agent-integration&lt;/goal&gt;
          &lt;/goals&gt;
        &lt;/execution&gt;
</code></pre>
<p><code>post-integration-test</code> runs the report for integration tests:</p>
<pre><code>        &lt;execution&gt;
          &lt;id&gt;post-integration-test&lt;/id&gt;
          &lt;goals&gt;
            &lt;goal&gt;report-integration&lt;/goal&gt;
          &lt;/goals&gt;
        &lt;/execution&gt;
</code></pre>
<p><code>merge-results</code> will merge the code coverage results of unit and integration tests into a new file, <code>aggregate.exec</code>:</p>
<pre><code>        &lt;execution&gt;
          &lt;id&gt;merge-results&lt;/id&gt;
          &lt;phase&gt;verify&lt;/phase&gt;
          &lt;goals&gt;
            &lt;goal&gt;merge&lt;/goal&gt;
          &lt;/goals&gt;
          &lt;configuration&gt;
            &lt;fileSets&gt;
              &lt;fileSet&gt;
                &lt;directory&gt;${project.build.directory}&lt;/directory&gt;
                &lt;includes&gt;
                  &lt;include&gt;*.exec&lt;/include&gt;
                &lt;/includes&gt;
                &lt;excludes&gt;
                  &lt;exclude&gt;aggregate.exec&lt;/exclude&gt;
                &lt;/excludes&gt;
              &lt;/fileSet&gt;
            &lt;/fileSets&gt;
            &lt;destFile&gt;${project.build.directory}/aggregate.exec&lt;/destFile&gt;
          &lt;/configuration&gt;
        &lt;/execution&gt;
</code></pre>
<p><code>post-merge-report</code> will generate the report for the aggregate coverage:</p>
<pre><code>        &lt;execution&gt;
          &lt;id&gt;post-merge-report&lt;/id&gt;
          &lt;phase&gt;verify&lt;/phase&gt;
          &lt;goals&gt;
            &lt;goal&gt;report&lt;/goal&gt;
          &lt;/goals&gt;
          &lt;configuration&gt;
            &lt;dataFile&gt;${project.build.directory}/aggregate.exec&lt;/dataFile&gt;
            &lt;outputDirectory&gt;${project.reporting.outputDirectory}/jacoco-aggregate&lt;/outputDirectory&gt;
          &lt;/configuration&gt;
        &lt;/execution&gt;
</code></pre>
<p><code>check-aggregate</code> will break the build if the aggregate code coverage is not good enough:</p>
<pre><code>        &lt;execution&gt;
          &lt;id&gt;check-aggregate&lt;/id&gt;
          &lt;phase&gt;verify&lt;/phase&gt;
          &lt;goals&gt;
            &lt;goal&gt;check&lt;/goal&gt;
          &lt;/goals&gt;
          &lt;configuration&gt;
            &lt;dataFile&gt;${project.build.directory}/aggregate.exec&lt;/dataFile&gt;
            &lt;rules&gt;
              &lt;rule&gt;
                &lt;element&gt;BUNDLE&lt;/element&gt;
                &lt;limits&gt;
                  &lt;limit&gt;
                    &lt;counter&gt;INSTRUCTION&lt;/counter&gt;
                    &lt;value&gt;COVEREDRATIO&lt;/value&gt;
                    &lt;minimum&gt;${jacoco.aggregate.limit.instruction-ratio}&lt;/minimum&gt;
                  &lt;/limit&gt;
                  &lt;limit&gt;
                    &lt;counter&gt;BRANCH&lt;/counter&gt;
                    &lt;value&gt;COVEREDRATIO&lt;/value&gt;
                    &lt;minimum&gt;${jacoco.aggregate.limit.branch-ratio}&lt;/minimum&gt;
                  &lt;/limit&gt;
                &lt;/limits&gt;
              &lt;/rule&gt;
            &lt;/rules&gt;
          &lt;/configuration&gt;
        &lt;/execution&gt;
</code></pre>
<p>The thresholds are using properties, so that they can be clearly defined in the properties section of the pom. This also allows for some streamlining of the configuration, by placing JaCoCo's configuration in a parent pom and leaving only the threshold properties in the child pom.</p>
