---
layout: post
title: Versioning Deployed Web Applications
date: 2013-11-09 07:16:43.000000000 +01:00
published: true
tags:
  - continuous deployment
  - continuous integration
  - versioning
---

In this post, I'm going to discuss the setup I have for deploying an ASP.NET
application in Linux.

The application is actually my pet project BuzzStats, so that name appears all
over the place here. Feel free to think of it as 'HelloWorldApp' or 'MyWebApp'.

Here's a nice diagram I made that illustrates my current deployment process:

<img src="{{ site.baseurl }}/assets/2013/drawing.png" />

The basic points are:

<ul>
<li>the build server has the concept of a 'version number'</li>
<li>it is possible to version the assemblies with that version number</li>
<li>it is possible to use the same version number to version the <em>deployed</em> application</li>
<li>it is possible to switch between these deployed versions on the web server</li>
</ul>

The setup:

<ul>
<li>Developer's workstation:
<ul>
<li>doesn't matter, as long as he can push changes to GIT/SSH</li>
</ul>
</li>
<li>Code server:
<ul>
<li>Ubuntu with SSH enabled to serve GIT repository</li>
</ul>
</li>
<li>Build server:
<ul>
<li>Ubuntu</li>
<li>Jenkins</li>
<li>Mono</li>
</ul>
</li>
<li>Web server:
<ul>
<li>Ubuntu</li>
<li>Apache</li>
<li>Mono</li>
<li>Mod_Mono</li>
</ul>
</li>
</ul>

In my current setup, the build server and the web server are actually the same
physical machine. My next step would be to separate that also.

<h2>Versioning deployed web application</h2>

To support versions of deployed web applications, I use symbolic links.

Typically, you would find the application under <code>/var/www/BuzzStats</code>.
I follow that convention, but I make a symbolic link to the actual place where
the application lives.

```
/var/www/BuzzStats -> /opt/BuzzStats/current
```

and that one is also a symbolic link:

```
ngeor@box:~$ ls -l /opt/BuzzStats
drwxrwsr-x 11 jenkins  www-data 4096 Nov  7 21:14 1.5.4.161
drwxrwsr-x 11 jenkins  www-data 4096 Nov  7 21:28 1.5.4.162
drwxrwsr-x 11 jenkins  www-data 4096 Nov  8 21:45 1.5.4.164
lrwxrwxrwx  1 www-data www-data    9 Nov  8 21:45 current -> 1.5.4.164
```

You can see that there are some folders here, e.g. <code>1.5.4.161</code>. You
might recognize the format of a .NET assembly version number. This version
number is generated by the build server. The build server also creates this
<strong>version folder</strong> here and deploys the corresponding version.

<strong>Security note</strong>: Please notice that for that to work, the folder
needs to be writable by the group, which can be a security issue. Additionally,
to automatically remove version folders automatically (not discussed in this
blog post), you also need the version folders themselves to be writable.

So the application is served from <code>/var/www/BuzzStats</code>, as one would
typically expect to avoid surprises. That one is a symbolic link to
<code>/opt/BuzzStats/current</code>. And finally that one in turn is a symbolic
link pointing to the <strong>active</strong> version folder.

Switching between versions is as easy as changing the symbolic link of
<code>current</code> to point to a different version folder. Activate the latest
and greatest, figure our there's a missing image? Rollback immediately and
easily to the previous version.

<h2>Automatic build</h2>

Let's have a look at how the version number can be generated on the build
server.

<h3>Version Number</h3>

In Jenkins, I use the
<a href="http://wiki.hudson-ci.org/display/HUDSON/Version+Number+Plugin">Version
Number Plugin</a> to create a formatted version number. These are my settings:

<ul>
<li>Environment Variable Name : <code>ASSEMBLY_VERSION_NUMBER</code></li>
<li>Version Number Format String : <code>1.5.4.${BUILD_NUMBER}</code></li>
<li>Build Display Name : Check the 'Use the formatted version number for build display name' option.</li>
<li>Project Start Date : 2010-11-27 (not important, but it's been almost three years! :-) )</li>
</ul>

With this setup, I have an environment variable called
<code>ASSEMBLY_VERSION_NUMBER</code> which will contain a value like
<code>1.5.4.42</code> that will be incremented automatically every time Jenkins
bakes a new build.

<strong>A note on version semantics</strong>: for now I'm using a simple
solution. The first part of the version is hard-coded in my Jenkins settings
(<code>1.5.4</code>). The last part is Jenkins' own build number which is
automatically incremented. You can chose a different strategy for the version,
e.g. based on the date of the build. I will probably also change this in the
future so that only the <code>1.5</code> part is hard-coded. If you like this
topic (I do), you can further read <a href="http://semver.org/">Semantic
Versioning 2.0.0</a> and
<a href="http://haacked.com/archive/2006/09/27/Which_Version_of_Version.aspx">Which
Version of Version?</a>.

<h3>Build Steps</h3>

Now that we have the version number as an environment variable, we can use it
during the build process.

<ul>
<li><strong>Pre-Build</strong>: Modify AssemblyInfo.cs files to use the <code>ASSEMBLY_VERSION_NUMBER</code>.This will make the built assemblies use the same version number. I've used various ways in the past, for now I'm doing it with a simple shell script:

```
#!/bin/sh

# patch assemblies

if [ -z "${ASSEMBLY_VERSION_NUMBER}" ]; then
    echo "Missing ASSEMBLY_VERSION_NUMBER"
    exit 1
fi

for FILE in `find . -name AssemblyInfo.cs`
do
    echo "Patching $FILE"
    sed -i -r "s/[0-9]+.[0-9]+.[0-9]+.[0-9]+/${ASSEMBLY_VERSION_NUMBER}/g" $FILE
done
```

</li>
<li><strong>Build</strong>: Simply run <code>xbuild</code>, mono's msbuild equivalent. This <em>actually works</em> (TM) these days, also with full NuGet support for <a href="http://docs.nuget.org/docs/reference/package-restore">package restore</a>.</li>
<li><strong>Package</strong> the web site into a folder, preparing for deployment. I currently do this with a very old NAnt script. The result is a temporary folder ready to be deployed (as in copy-pasted) to the final deployment location.</li>
<li><strong>Deploy</strong> to a local folder. Again with the same old NAnt script:
<ul>
<li>create the folder <code>/opt/BuzzStats/${ASSEMBLY_VERSION_NUMBER}</code></li>
<li>copy the package into that folder</li>
</ul>

This is my current limitation: I can only deploy to a local folder, so the web
server and the build server have to be on the same machine. Once I go past that
(perhaps using <code>rsync</code>), I will be able to deploy automatically to my
actual web server where this blog is hosted.</li>

</ul>
<h2>Activating and rolling-back</h2>

With this setup, after each build we have a new version folder under the main
folder <code>/opt/BuzzStats</code>. The version is not <em>activated</em>;
remember that the web application is still pointing to
<code>/var/www/BuzzStats</code> which in turn points to
<code>/opt/BuzzStats/current</code> which still points to the old version.

Activation could also be part of deployment:

<ul>
<li>remove the current link (<code>unlink /opt/BuzzStats/current</code>)</li>
<li>create a new symbolic link (<code>ln -s /opt/BuzzStats/${ASSEMBLY_VERSION_NUMBER} /opt/BuzzStats/current</code>)</li>
</ul>

One caveat here is that mono doesn't detect the change and still continues to
run on the old folder. The only way I've found so far to "fix" this is to kill
the mono process with <code>pkill mono</code>. Obviously this will kill all mono
processes which could be a bit more than what you want...

So, for now, I've left that as a manual step. I've written a small web
application to manage activation and rolling-back using a simple UI and I'll
show/share that on a follow-up post.
