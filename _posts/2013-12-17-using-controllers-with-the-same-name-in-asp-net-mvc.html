---
layout: post
title: Using controllers with the same name in ASP.NET MVC
date: 2013-12-17 14:18:36.000000000 +01:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
tags: []
meta:
  _edit_last: '14213986'
  restapi_import_id: 586b47d26eba1
  original_post_id: '14'
  _wp_old_slug: '14'
  _publicize_job_id: '4016814985'
author:


  display_name: ngeor
  first_name: Nikolaos
  last_name: Georgiou
---
<h2>Introduction</h2>
<p>Let&#039;s consider the following ASP.NET MVC structure:</p>
<p>[code]<br />
MvcSite<br />
└ Controllers<br />
    ├ HomeController<br />
    └ NewsletterController<br />
└ Models<br />
    └ NewsletterModel<br />
└ Views<br />
    └ Home<br />
        └ Index<br />
    └ Newsletter<br />
        └ Index<br />
[/code]</p>
<p>There&#039;s just a homepage, where the view includes a newsletter box rendered as a partial view by the newsletter controller. The newsletter box shows an e-mail and a label asking the user to subscribe to the newsletter.</p>
<p>Imagine that we want to extend the newsletter box functionality, allowing the user to type his name too. However, we don&#039;t want to modify the original controller. A possible use case for this is where you have access to the original code but you don&#039;t want to modify it, e.g. the code is from an open source application and you want to be able to update to new versions easier (well, it&#039;s never gonna be that easy, but ok).</p>
<p>We end up with the following scheme:</p>
<p>[code]<br />
MvcSite<br />
└ Controllers<br />
    ├ HomeController<br />
    └ NewsletterController<br />
└ Models<br />
    └ NewsletterModel<br />
└ Views<br />
    └ Home<br />
        └ Index<br />
    └ Newsletter<br />
        └ Index<br />
└ Special<br />
    └ Controllers<br />
        └ NewsletterController<br />
    └ Models<br />
        └ NewsletterModel<br />
    └ Views<br />
        └ Newsletter<br />
            └ Index<br />
[/code]</p>
<p>There&#039;s a new folder, <code>Special</code>, that contains the familiar MVC structure. However, it only contains what we want to override.</p>
<p>Notice that there are now two controllers by the same name, <code>NewsletterController</code>. They are in the expected namespaces, <code>MvcSite.Controlers</code> and <code>MvcSite.Special.Controllers</code>. However, in ASP.NET MVC the significant identifier of a controller is just its name, not the full type name. Therefore, we have an ambiguity problem.</p>
<h2>Routing</h2>
<p>To fix this, we&#039;re going to modify the default route:</p>
<p>[code]<br />
routes.MapRoute(<br />
    name: "Default",<br />
    url: "{controller}/{action}/{id}",<br />
    defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional });<br />
[/code]</p>
<p>by <a href="http://stackoverflow.com/questions/5343053/namespaces-equivalent-in-asp-net-mvc">specifying the namespaces</a> it should use:</p>
<p>[code]<br />
routes.MapRoute(<br />
    name: "Default",<br />
    url: "{controller}/{action}/{id}",<br />
    defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional },<br />
    namespaces: new[] { "MvcSite.Special.Controllers" });<br />
[/code]</p>
<p>The controllers we haven&#039;t overriden will still be picked up as fallback, so the home page, served by the <code>HomeController</code> will still work.</p>
<p>A different solution to the ambiguity problem is to implement an additional route that maps only the overriden controllers. This can be a route identical to the default, but with an extra constraint on the <code>controller</code> parameter. The constraint will check at runtime with reflection if there&#039;s a controller class under <code>MvcSite.Special.Controllers</code>.</p>
<h2>View selection</h2>
<p>Even though we&#039;re now using the correct controller, the view is still the old one. That&#039;s because the controller&#039;s action looks like this:</p>
<p>[code]<br />
public override ActionResult Index()<br />
{<br />
    return PartialView("Index", new NewsletterModel { Reason = "best newsletter ever!" });<br />
}<br />
[/code]</p>
<p>The default view engine is searching still on a path like <code>Views/Controller/Action</code> and the controller is still identified as <code>Newsletter</code>.</p>
<p>One way of solving it is by specifying an explicit file path in the controller action:</p>
<p>[code]<br />
public override ActionResult Index()<br />
{<br />
    return PartialView("~/Special/Views/Newsletter/Index.cshtml", new NewsletterModel { Reason = "best newsletter ever!" });<br />
}<br />
[/code]</p>
<p>But, arguably, this looks a bit ugly.</p>
<p>We can solve this in a different way, by <a href="http://weblogs.asp.net/imranbaloch/archive/2011/06/27/view-engine-with-dynamic-view-location.aspx">overriding the default view engine</a> in <code>Global.asax</code>:</p>
<p>[code]<br />
ViewEngines.Engines.Clear();<br />
ViewEngines.Engines.Add(new CustomViewEngine());<br />
[/code]</p>
<p>and the implementation of the <code>CustomViewEngine</code>:</p>
<p>[code]<br />
public class CustomViewEngine : RazorViewEngine<br />
{<br />
    public CustomViewEngine()<br />
    {<br />
        ViewLocationFormats = new[]<br />
            {<br />
                "~/Special/Views/{1}/{0}.cshtml"<br />
            }.Union(ViewLocationFormats).ToArray();</p>
<p>        PartialViewLocationFormats = new[]<br />
            {<br />
                "~/Special/Views/{1}/{0}.cshtml"<br />
            }.Union(PartialViewLocationFormats).ToArray();<br />
    }<br />
}<br />
[/code]</p>
<p>So we&#039;re using a new view engine, based on the default <code>RazorViewEngine</code>, that will first check for view files into our <code>Special/Views</code> subfolder before diving into the default folders.</p>
<p>Note that you&#039;ll also need to copy the <code>web.config</code> of the regular Views folder into the Special/Views folder, otherwise compilation of the views <a href="http://stackoverflow.com/questions/6389055/the-name-model-does-not-exist-in-current-context-in-mvc3">won&#039;t work</a>.</p>
