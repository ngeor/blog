---
layout: post
title: 'CD with Helm part 4: Helm Intro'
date: 2017-11-27 20:27:37.000000000 +01:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
tags:
- blog-helm-sample
- Docker
- Helm
- Kubernetes
meta:
  _thumbnail_id: '3373'
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
  _publicize_job_id: '11892855999'
author:


  display_name: ngeor
  first_name: Nikolaos
  last_name: Georgiou
---
<p>In the previous post we had a first look at Kubernetes and deployed our hello world app on a local cluster using the CLI. The simple commands we used are good enough for a first taste. However, the full power of Kubernetes comes with using configuration files. Helm builds on top of that, taking these configuration files to the next level.</p>
<p><!--more--></p>
<p>Let's start with the deployment we created last time. We had created it with the command <code>kubectl run</code>. The equivalent YAML file for Kubernetes looks like this:</p>

```
apiVersion: extensions/v1beta1<br />
kind: Deployment<br />
spec:<br />
  replicas: 1<br />
  template:<br />
    metadata:<br />
      labels:<br />
        app: blog-helm<br />
    spec:<br />
      containers:<br />
        - name: blog-helm<br />
          image: blog-helm<br />
          imagePullPolicy: Never<br />
          ports:<br />
            - containerPort: 3000<br />
```

<p>This file works fine and we can use <code>kubectl create -f deployment.yaml</code> to run it. The documentation has examples but also proper <a href="https://kubernetes.io/docs/api-reference/v1.8/#deployment-v1beta2-apps" target="_blank">API reference</a> for these objects. Please note that Helm builds on top of this, so this documentation is still needed.</p>
<p><a href="https://helm.sh/" target="_blank">Helm</a> is a tool which builds on top of this. It calls itself "the package manager for Kubernetes", a fair statement, as it allows us to package all the necessary YAML files into a single versioned entity called a <strong>Helm chart</strong>. It offers a <strong>templating language</strong>, which allows us to keep our Helm chart generic. Thanks to that, we'll be able to deploy our application on multiple environments (think DTAP) without much effort. And all this without inventing its own syntax; it builds on top of the Kubernetes configuration.</p>
<p>Let's give it a try. First, you'll need to <a href="https://docs.helm.sh/using_helm/#installing-helm" target="_blank">install Helm</a> (e.g. <code>brew install kubernetes-helm</code>, unfortunately no Chocolatey package yet). Note that Helm has a client-side part, but also a <strong>server-side part, which is called Tiller</strong>. Helm uses Tiller to manage its releases. Make sure you install that with <code>helm init</code>:</p>

```
PS&gt; helm init<br />
$HELM_HOME has been configured at C:\Users\ngeor\.helm.</p>
<p>Tiller (the Helm server-side component) has been installed into your Kubernetes Cluster.<br />
Happy Helming!<br />
```

<p>Give it some time while it installs itself in the minikube cluster. You can monitor progress with <code>kubectl get pods -n kube-system</code>:</p>

```
PS&gt; kubectl get pods -n kube-system<br />
NAME                            READY     STATUS              RESTARTS   AGE<br />
kube-addon-manager-minikube     1/1       Running             0          5m<br />
kube-dns-6fc954457d-97wtm       3/3       Running             0          5m<br />
kubernetes-dashboard-5zfj6      1/1       Running             0          5m<br />
tiller-deploy-cffb976df-rm4l7   0/1       ContainerCreating   0          0s</p>
<p>PS&gt; kubectl get pods -n kube-system<br />
NAME                            READY     STATUS    RESTARTS   AGE<br />
kube-addon-manager-minikube     1/1       Running   0          12m<br />
kube-dns-6fc954457d-97wtm       3/3       Running   0          11m<br />
kubernetes-dashboard-5zfj6      1/1       Running   0          11m<br />
tiller-deploy-cffb976df-rm4l7   1/1       Running   0          6m<br />
```

<p>Let's <strong>create the Helm chart</strong> for our hello world application. Start by creating a folder called <code>helm</code> (or any name you want) and inside that folder let's create our chart with <code>helm create blog-helm</code>:</p>
<p>[code]<br />
PS&gt; mkdir helm<br />
PS&gt; cd helm<br />
PS&gt; helm create blog-helm<br />
[/code]</p>
<p>We get a bunch of new files (<a href="https://github.com/ngeor/blog-helm/tree/effce7a47986f806121b7d608c68164488b0bb97" target="_blank">browse code at this point</a>):</p>
<p><img src="{{ site.baseurl }}/assets/2017-11-27-19_02_31-blog-helm-visual-studio-code.png" alt="2017-11-27 19_02_31-blog-helm - Visual Studio Code.png" width="755" height="693" class="alignnone size-full wp-image-3371" /></p>
<ul>
<li><code>.helmignore</code> will be used to ignore files when packaging the chart. It's similar to <code>.gitignore</code> and <code>.dockerignore</code>.</li>
<li><code>Chart.yaml</code> is the main file of the chart. It's mainly there to identify the chart's name and its version.</li>
<li><code>values.yaml</code> is a set of values that can be used in the templates of the chart. You can specify here whatever values you want. The interesting thing is that when you're using the chart, you can override these values. We'll see how this works great when modelling environment specific configuration for deploying to multiple environments on a next post.</li>
<li><code>_helpers.tpl</code> defines some handy helpers that can be used in the templates.</li>
<li><code>deployment.yaml</code>, <code>ingress.yaml</code> and <code>service.yaml</code> are templates which describe our Kubernetes deployment, ingress and service respectively.</li>
<li><code>NOTES.txt</code> will be used to display a help message when we'll install the Helm chart.</li>
</ul>
<p>We can have a look at <code>service.yaml</code>:</p>

{% raw %}
```
apiVersion: v1<br />
kind: Service<br />
metadata:<br />
  name: {{ template &quot;fullname&quot; . }}<br />
  labels:<br />
    app: {{ template &quot;name&quot; . }}<br />
    chart: {{ .Chart.Name }}-{{ .Chart.Version | replace &quot;+&quot; &quot;_&quot; }}<br />
    release: {{ .Release.Name }}<br />
    heritage: {{ .Release.Service }}<br />
spec:<br />
  type: {{ .Values.service.type }}<br />
  ports:<br />
    - port: {{ .Values.service.externalPort }}<br />
      targetPort: {{ .Values.service.internalPort }}<br />
      protocol: TCP<br />
      name: {{ .Values.service.name }}<br />
  selector:<br />
    app: {{ template &quot;name&quot; . }}<br />
    release: {{ .Release.Name }}<br />
```
{% endraw %}

<p>The <a href="https://docs.helm.sh/chart_template_guide/#the-chart-template-developer-s-guide" target="_blank">templating syntax of Helm</a> is based on <a href="https://golang.org/pkg/text/template/" target="_blank">Go templates</a>. The go language is attracting a lot of attention these days and coincidentally all these tools are written in go. Some quick observations:</p>
<ul>
<li>we can reference values found in <code>Chart.yaml</code> e.g. <code>{{ .Chart.Name }}</code></li>
<li>we can reference values found in <code>values.yaml</code> e.g. <code>{{ .Values.service.name }}</code>. Keep in mind again that we can provide overrides when rolling out the app with Helm.
</li>
</ul>
<p>Let's see our <code>values.yaml</code>:</p>

```
# Default values for blog-helm.<br />
# This is a YAML-formatted file.<br />
# Declare variables to be passed into your templates.<br />
replicaCount: 1<br />
image:<br />
  repository: nginx<br />
  tag: stable<br />
  pullPolicy: IfNotPresent<br />
service:<br />
  name: nginx<br />
  type: ClusterIP<br />
  externalPort: 80<br />
  internalPort: 80<br />
ingress:<br />
  enabled: false<br />
  # Used to create an Ingress record.<br />
  hosts:<br />
    - chart-example.local<br />
  annotations:<br />
    # kubernetes.io/ingress.class: nginx<br />
    # kubernetes.io/tls-acme: &quot;true&quot;<br />
  tls:<br />
    # Secrets must be manually created in the namespace.<br />
    # - secretName: chart-example-tls<br />
    #   hosts:<br />
    #     - chart-example.local<br />
resources: {}<br />
  # We usually recommend not to specify default resources and to leave this as a conscious<br />
  # choice for the user. This also increases chances charts run on environments with little<br />
  # resources, such as Minikube. If you do want to specify resources, uncomment the following<br />
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.<br />
  # limits:<br />
  #  cpu: 100m<br />
  #  memory: 128Mi<br />
  # requests:<br />
  #  cpu: 100m<br />
  #  memory: 128Mi</p>
```

<p>By default, it doesn't install our application but it installs nginx. Let's fix this:</p>

```
image:<br />
  repository: blog-helm<br />
  tag: latest<br />
  pullPolicy: Never<br />
[/code]</p>
<p>And also we need to change the service type to NodePort and adjust the internal port:</p>
<p>[code]<br />
service:<br />
  name: blog-helm<br />
  type: NodePort<br />
  externalPort: 80<br />
  internalPort: 3000<br />
```

<p>Now that we have our Helm chart (<a href="https://github.com/ngeor/blog-helm/tree/a6450f41ad634c7feb4aae6f07749c4617995620" target="_blank">browse code at this point</a>), we can use it to deploy our application:</p>

```
PS&gt; helm install ./blog-helm<br />
NAME:   callous-koala<br />
LAST DEPLOYED: Mon Nov 27 19:46:16 2017<br />
NAMESPACE: default<br />
STATUS: DEPLOYED</p>
<p>RESOURCES:<br />
==&gt; v1/Service<br />
NAME                     CLUSTER-IP  EXTERNAL-IP  PORT(S)       AGE<br />
callous-koala-blog-helm  10.0.0.223  &lt;nodes&gt;      80:30129/TCP  1s</p>
<p>==&gt; v1beta1/Deployment<br />
NAME                     DESIRED  CURRENT  UP-TO-DATE  AVAILABLE  AGE<br />
callous-koala-blog-helm  1        1        1           0          1s</p>
<p>NOTES:<br />
1. Get the application URL by running these commands:<br />
  export NODE_PORT=$(kubectl get --namespace default -o jsonpath=&quot;{.spec.ports[0].nodePort}&quot; services callous-koala-blog-helm)<br />
  export NODE_IP=$(kubectl get nodes --namespace default -o jsonpath=&quot;{.items[0].status.addresses[0].address}&quot;)<br />
  echo http://$NODE_IP:$NODE_PORT<br />

```

<p>Since we didn't provide a name, Helm generates a release name automatically (<code>callous-koala</code>).</p>
<p>Note that the only file we had to change is <code>values.yaml</code>. That's because the default chart that gets generated automatically by Helm is quite a good starting point.</p>
<p>We can delete the release with <code>helm delete --purge callous-koala</code>. If we want to install it again with a predictable name, we can run <code>helm install ./blog-helm --name blog-helm</code>. We can see the releases we have with <code>helm list</code>:</p>

```
PS&gt; helm list<br />
NAME            REVISION        UPDATED                         STATUS          CHART           NAMESPACE<br />
blog-helm       1               Mon Nov 27 20:01:34 2017        DEPLOYED        blog-helm-0.1.0 default<br />
```

<p>And we can upgrade an existing release if we want to with <code>helm upgrade</code>.</p>
<p>While this is all very nice and interesting, we are far from implementing a continuous delivery pipeline. We'll start doing that in the next posts. The main points to think about is to see what our artifacts are, how to version them and how to support multiple environments for deployments. The goal is to be able to use Helm to deploy whatever (whatever branch), wherever (any environment).</p>
