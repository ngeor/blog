---
layout: post
title: Exceptions using type initializer based singletons
date: 2011-06-09 21:59:00.000000000 +02:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
tags: []
meta:
  restapi_import_id: 586b47d26eba1
  original_post_id: '66'
  _wp_old_slug: '66'
  _edit_last: '14213986'
  _publicize_job_id: '4017169148'
author:


  display_name: ngeor
  first_name: Nikolaos
  last_name: Georgiou
---
<p>A popular web page describing how to implement a singleton in C# is <a href="http://www.yoda.arachsys.com/csharp/singleton.html" target="_blank">this one</a>, where several ways to implement a singleton are discussed. I usually pick the last option, which, according to the author of that page, has the most benefits. The author goes on to mention some problems that can occur if an exception is thrown in the constructor, but I never paid attention to that until recently.</p>
<p>In our project at work, we implemented a small singleton based on that last option, the one using type initializers. The purpose of the singleton was to fetch some records from the database (around 200 of them) and cache them in memory. The call to fetch the records from the database was done in the constructor of the singleton, so our code looked more or less like this:</p>
<p>[code]<br />
public sealed class Singleton<br />
{<br />
    private Dictionary cache;</p>
<p>    Singleton()<br />
    {<br />
        // access database<br />
        cache = RetrieveData();<br />
    }</p>
<p>    public string GetValue(string key)<br />
    {<br />
        return cache[key];<br />
    }</p>
<p>    private Dictionary RetrieveData()<br />
    {<br />
        // access the heavy database query<br />
        return data;<br />
    }</p>
<p>    public static Singleton Instance<br />
    {<br />
        get<br />
        {<br />
            return Nested.instance;<br />
        }<br />
    }</p>
<p>    class Nested<br />
    {<br />
        // Explicit static constructor to tell C# compiler<br />
        // not to mark type as beforefieldinit<br />
        static Nested()<br />
        {<br />
        }</p>
<p>        internal static readonly Singleton instance = new Singleton();<br />
    }<br />
}<br />
[/code]</p>
<p>Most of the above code is the boilerplate singleton code. Notice that in the constructor of the Singleton class, the database is been accessed.</p>
<p>What will happen is the database is out of reach temporarily? We were experiencing some SQL timeouts. I thought that once the SQL problems had been resolved, .NET would be able to create the singleton normally. I found however that this isn&#039;t the case. Once an exception is thrown in the type initialization, the exception just stays there and gets thrown for ever and ever. The exception never goes away. Our database logs got many error rows about the same exception, which kind of gave it away. Since the singleton was accessed in the URL rewriter of our site, it basically made the entire site give the 500 page until somebody restarted IIS. Ouch.</p>
<p>The bug however didn&#039;t occur that often. First of all, we didn&#039;t have that many database problems. Secondly, the database problem would have to occur at the same time when the singleton was initialized. In the entire life span of the web application (and therefore the singleton), that&#039;s a bit improbable. Yet, it happened. Twice. But it got noticed so here&#039;s what I did to solve this.</p>
<p>This is a different way to write the class. The same singleton pattern is used while the class doesn&#039;t suffer from this problem:</p>
<p>[code]<br />
public sealed class Singleton<br />
{<br />
    private Dictionary cache;<br />
    &lt;strong&gt;private object cacheLock = new object();&lt;/strong&gt;</p>
<p>    Singleton()<br />
    {<br />
    }</p>
<p>    public string GetValue(string key)<br />
    {<br />
        &lt;strong&gt;EnsureData();&lt;/strong&gt;</p>
<p>        return cache[key];<br />
    }<br />
&lt;strong&gt;<br />
    private void EnsureData()<br />
    {<br />
        if (cache == null)<br />
        {<br />
            lock (cacheLock)<br />
            {<br />
                if (cache == null)<br />
                {<br />
                    cache = RetrieveData();<br />
                }<br />
            }<br />
        }<br />
    }&lt;/strong&gt;</p>
<p>    private Dictionary RetrieveData()<br />
    {<br />
        // access the heavy database query<br />
        return data;<br />
    }</p>
<p>    public static Singleton Instance<br />
    {<br />
        get<br />
        {<br />
            return Nested.instance;<br />
        }<br />
    }</p>
<p>    class Nested<br />
    {<br />
        // Explicit static constructor to tell C# compiler<br />
        // not to mark type as beforefieldinit<br />
        static Nested()<br />
        {<br />
        }</p>
<p>        internal static readonly Singleton instance = new Singleton();<br />
    }<br />
}<br />
[/code]</p>
<p>What did we change? The constructor is now empty. That means that the singleton pattern is now responsible only for one thing: initializing the singleton in a thread safe way. Nothing more, so nothing can go wrong with the type initialization. So we got rid of the "permanent" exception problem.</p>
<p>We still need to load the cache in a thread safe way. That is been done with the EnsureData method. If the cache hasn&#039;t been populated yet, we lock on the helper cacheLock object to ensure only one thread can continue from there on. We check again that the cache is still null and then we access the database. This technique is called the <a href="http://en.wikipedia.org/wiki/Double-checked_locking" target="_blank">Double-checked locking</a>. With this implementation, SQL timeouts will end up to the 500 page as expected, but once the database is back online the site will resume working normally.</p>
<p>If you would like to see it in action, you can paste the following code in a demo web application. In your Default.aspx Page_Load, access the Singleton.Instance.Greet method. See that "DateTime.Now.Minutes &lt; 30" line? Change it to something that will throw an exception, so if the time is 11:47, make it for instance "DateTime.Now.Minutes &lt; 50". When you load the Default.aspx, you will get an exception with the date time as an error message. Loading the page over and over again will still show the same date and time when the exception first occurred and the exception will keep on occurring, even after the time has passed 11:50.</p>
<p>[code]<br />
public sealed class Singleton<br />
{<br />
    private Dictionary cache;</p>
<p>    Singleton()<br />
    {<br />
        if (DateTime.Now.Minutes &lt; 30)<br />
        {<br />
            throw new Exception(DateTime.Now.ToString());<br />
        }<br />
    }</p>
<p>    public string Greet()<br />
    {<br />
        return &quot;Hello world&quot;;<br />
    }</p>
<p>    public static Singleton Instance<br />
    {<br />
        get<br />
        {<br />
            return Nested.instance;<br />
        }<br />
    }</p>
<p>    class Nested<br />
    {<br />
        // Explicit static constructor to tell C# compiler<br />
        // not to mark type as beforefieldinit<br />
        static Nested()<br />
        {<br />
        }</p>
<p>        internal static readonly Singleton instance = new Singleton();<br />
    }<br />
}<br />
[/code]</p>
<p>It&#039;s a tricky situation, one of those .NET features that you probably only get to know the hard way. Hope this helps.</p>
