---
layout: post
title: TDD with .NET Core and Visual Studio Code
date: 2017-06-05 14:49:15.000000000 +02:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Code
tags:
- ".NET"
- ".NET Core"
- C Sharp
- tdd
- Visual Studio Code
meta:
  _oembed_4546be6b8db1d26a55f6bd44ffbc504c: "{{unknown}}"
  _oembed_859efc9b4c04ff46f7c78798381de12e: "{{unknown}}"
  _oembed_8ce62b25a36152809988d0d87b63a995: "{{unknown}}"
  _edit_last: '14213986'
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
  _oembed_a28fa228a8b6c58bc0a00b4a8d9bba76: "{{unknown}}"
  _publicize_job_id: '5799248191'
  _oembed_a04df6c4d1bb11c0c2b8eb2c54bb19c7: "{{unknown}}"
  _oembed_4f6474b056e397704f5bdbf12c9aaf7d: "{{unknown}}"
author:


  display_name: ngeor
  first_name: Nikolaos
  last_name: Georgiou
---
<p>In this post we'll see how to create a .NET Core solution with two projects with using nothing but the command line. Once that is setup, we'll do a bit of TDD using Visual Studio Code.</p>
<p><!--more--></p>
<p>First, let's check that the .NET Core CLI is installed:</p>
<p>[code]</p>
<p>$ dotnet --version<br />
1.0.4</p>
<p>[/code]</p>
<p>If that is missing, you'll need to install it first.</p>
<p>If you just want to create a project (csproj file), you can follow these steps:</p>
<ul>
<li>create an empty directory named after your project <code>mkdir MyApp</code></li>
<li>change into that directory with <code>cd MyApp</code></li>
<li>and finally run <code>dotnet new console</code></li>
</ul>
<p>[code]</p>
<p>~/Dropbox/Playground/dotnetcore<br />
$ mkdir MyApp</p>
<p>~/Dropbox/Playground/dotnetcore<br />
$ cd MyApp</p>
<p>~/Dropbox/Playground/dotnetcore/MyApp<br />
$ dotnet new console<br />
Content generation time: 57,4 ms<br />
The template &quot;Console Application&quot; created successfully.</p>
<p>[/code]</p>
<p>This gives us a very simple result, just two files. The <code>Program.cs</code> which is the code of the hello world application and the project file, <code>MyApp.csproj</code>. This is the traditional csproj format, but it has gone through some diet. For example, it no longer mentions explicitly the source files of the project. This makes adding/removing files easier.</p>
<p>To restore the NuGet packages of a project, we can run <code>dotnet restore</code>:</p>
<p>[code]</p>
<p>$ dotnet restore<br />
Restoring packages for C:\Users\ngeor\Dropbox\Playground\dotnetcore\MyApp\MyApp.csproj...<br />
Generating MSBuild file C:\Users\ngeor\Dropbox\Playground\dotnetcore\MyApp\obj\MyApp.csproj.nuget.g.props.<br />
Generating MSBuild file C:\Users\ngeor\Dropbox\Playground\dotnetcore\MyApp\obj\MyApp.csproj.nuget.g.targets.<br />
Writing lock file to disk. Path: C:\Users\ngeor\Dropbox\Playground\dotnetcore\MyApp\obj\project.assets.json<br />
Restore completed in 677,66 ms for C:\Users\ngeor\Dropbox\Playground\dotnetcore\MyApp\MyApp.csproj.</p>
<p>NuGet Config files used:<br />
C:\Users\ngeor\AppData\Roaming\NuGet\NuGet.Config</p>
<p>Feeds used:<br />
https://api.nuget.org/v3/index.json</p>
<p>[/code]</p>
<p>To build a project, simply <code>dotnet build</code>:</p>
<p>[code]</p>
<p>$ dotnet build<br />
Microsoft (R) Build Engine version 15.1.1012.6693<br />
Copyright (C) Microsoft Corporation. All rights reserved.</p>
<p>MyApp -&gt; C:\Users\ngeor\Dropbox\Playground\dotnetcore\MyApp\bin\Debug\netcoreapp1.1\MyApp.dll</p>
<p>Build succeeded.<br />
0 Warning(s)<br />
0 Error(s)</p>
<p>Time Elapsed 00:00:01.82</p>
<p>[/code]</p>
<p>And we can also run it with <code>dotnet run</code>:</p>
<p>[code]</p>
<p>$ dotnet run<br />
Hello World!</p>
<p>[/code]</p>
<p>This is all great as a first step, but most likely you're going to need the traditional solution file (sln file) with multiple projects. For example, let's say we also want a unit test project. There's no need to start fiddling around with editing files manually and there's no need to install Visual Studio either. This is all still possible from the command line of .NET Core.</p>
<p>First, we'll create the directory structure like this:</p>
<ul>
<li>MyApp is the root folder that will contain the solution file</li>
<li>MyApp/MyApp.CLI is the folder that will contain the console project</li>
<li>MyApp/MyApp.Tests is the folder that will contain the unit test project</li>
</ul>
<p>Inside the MyApp folder, we'll create an empty solution file with <code>dotnet new sln</code>:</p>
<p>[code]</p>
<p>$ dotnet new sln<br />
Content generation time: 24,8464 ms<br />
The template &quot;Solution File&quot; created successfully.</p>
<p>[/code]</p>
<p>Inside the MyApp/MyApp.CLI folder, we'll create the hello world CLI project just like before:</p>
<p>[code]</p>
<p>$ dotnet new console<br />
Content generation time: 56,8044 ms<br />
The template &quot;Console Application&quot; created successfully.</p>
<p>[/code]</p>
<p>Inside the MyApp/MyApp.Tests folder, we'll create a unit test project. .NET Core has templates for MSTest and xUnit, we'll use the latter:</p>
<p>[code]</p>
<p>$ dotnet new xunit<br />
Content generation time: 59,0936 ms<br />
The template &quot;xUnit Test Project&quot; created successfully.</p>
<p>[/code]</p>
<p>Now we need to include the new projects in the solution file. From the root MyApp folder, we use the <code>dotnet sln add</code> command:</p>
<p>[code]</p>
<p>$ dotnet sln add MyApp.CLI/MyApp.CLI.csproj MyApp.Tests/MyApp.Tests.csproj<br />
Project `MyApp.CLI\MyApp.CLI.csproj` added to the solution.<br />
Project `MyApp.Tests\MyApp.Tests.csproj` added to the solution.</p>
<p>[/code]</p>
<p>One last bit remains. The unit test project should have a reference to the CLI project, in order to be able to test it. That's done with <code>dotnet add reference</code> (from the MyApp/MyApp.Tests folder):</p>
<p>[code]</p>
<p>$ dotnet add reference ../MyApp.CLI/MyApp.CLI.csproj<br />
Reference `..\MyApp.CLI\MyApp.CLI.csproj` added to the project.</p>
<p>[/code]</p>
<p>It is possible to restore the packages for the entire solution by running <code>dotnet restore</code> on the top level folder. The same applies for <code>dotnet build</code> which will build all projects to the solution. For <code>dotnet run</code> however you'll need to be in the CLI project's folder or pass <code>--project</code> as an argument.</p>
<p>Now that we have a unit test project, we might as well use it. That's done with <code>dotnet test</code>:</p>
<p>[code]</p>
<p>$ dotnet test<br />
Build started, please wait...<br />
Build completed.</p>
<p>Test run for C:\Users\ngeor\Dropbox\Playground\dotnetcore\MyApp\MyApp.Tests\bin\Debug\netcoreapp1.1\MyApp.Tests.dll(.NETCoreApp,Version=v1.1)<br />
Microsoft (R) Test Execution Command Line Tool Version 15.0.0.0<br />
Copyright (c) Microsoft Corporation. All rights reserved.</p>
<p>Starting test execution, please wait...<br />
[xUnit.net 00:00:00.4280752] Discovering: MyApp.Tests<br />
[xUnit.net 00:00:00.5086923] Discovered: MyApp.Tests<br />
[xUnit.net 00:00:00.5436821] Starting: MyApp.Tests<br />
[xUnit.net 00:00:00.6580792] Finished: MyApp.Tests</p>
<p>Total tests: 1. Passed: 1. Failed: 0. Skipped: 0.<br />
Test Run Successful.<br />
Test execution time: 1,2565 Seconds</p>
<p>[/code]</p>
<p>Visual Studio Code has amazing support for .NET Core. Notice the "run test" and "debug test" labels above the unit test method:</p>
<p><img class="alignnone size-medium wp-image-2474" src="{{ site.baseurl }}/assets/2017-06-04-16_20_04-unittest1-cs-myapp-visual-studio-code.png?w=494" alt="2017-06-04 16_20_04-UnitTest1.cs - MyApp - Visual Studio Code" width="247" height="300" /></p>
<p>These labels are clickable, so you can run the test directly from the editor.</p>
<p>Let's do a bit of TDD by implementing a Greeter class. The Greeter class will be able to say hello to a person, so it will have a SayHello method.</p>
<p>We'll start by adding the Greeter test:</p>
<p><img class="alignnone size-medium wp-image-2482" src="{{ site.baseurl }}/assets/2017-06-04-16_24_57-greetertest-cs-myapp-visual-studio-code.png?w=582" alt="2017-06-04 16_24_57-GreeterTest.cs - MyApp - Visual Studio Code" width="291" height="300" /></p>
<p>since there's no <code>Greeter</code> class, that's the first error. Let's create the file in the MyApp.CLI project (no need to modify the csproj file!):</p>
<p><img class="alignnone size-medium wp-image-2487" src="{{ site.baseurl }}/assets/2017-06-04-16_26_42-greeter-cs-myapp-visual-studio-code.png?w=600" alt="2017-06-04 16_26_42-Greeter.cs - MyApp - Visual Studio Code" width="300" height="278" /></p>
<p>Back in the test, the editor is intelligent enough to propose importing the new class, a convenience usually found in full blown IDEs:</p>
<p><img class="alignnone size-medium wp-image-2491" src="{{ site.baseurl }}/assets/2017-06-04-16_28_07-greetertest-cs-myapp-visual-studio-code.png?w=600" alt="2017-06-04 16_28_07-GreeterTest.cs - MyApp - Visual Studio Code" width="300" height="183" /></p>
<p>The next step is to call the Greeter's (non-existing) <code>SayHello</code> method:</p>
<p><img class="alignnone size-medium wp-image-2495" src="{{ site.baseurl }}/assets/2017-06-04-16_30_26-greetertest-cs-myapp-visual-studio-code.png?w=600" alt="2017-06-04 16_30_26-GreeterTest.cs - MyApp - Visual Studio Code" width="300" height="54" /></p>
<p>The refactoring helper is great here too, it allows us to generate a method that throws a <code>NotImplementedException</code> (perfect for our TDD approach).</p>
<p>The final bit for our unit test is to write the assertion (and change the class to <code>public</code> for xUnit to see it, I forgot that bit...):</p>
<p><img class="alignnone size-medium wp-image-2504" src="{{ site.baseurl }}/assets/2017-06-04-16_36_16-greetertest-cs-myapp-visual-studio-code.png?w=600" alt="2017-06-04 16_36_16-GreeterTest.cs - MyApp - Visual Studio Code" width="300" height="299" /></p>
<p>Clicking the "run test" link leads to a failed test:</p>
<p><img class="alignnone size-large wp-image-2508" src="{{ site.baseurl }}/assets/2017-06-04-16_37_57-greetertest-cs-myapp-visual-studio-code.png?w=2048" alt="2017-06-04 16_37_57-GreeterTest.cs - MyApp - Visual Studio Code" width="1024" height="196" /></p>
<p>We need to implement the Greeter's method:</p>
<p><img class="alignnone size-medium wp-image-2511" src="{{ site.baseurl }}/assets/2017-06-04-16_40_04-greeter-cs-myapp-visual-studio-code.png?w=600" alt="2017-06-04 16_40_04-Greeter.cs - MyApp - Visual Studio Code" width="300" height="204" /></p>
<p>And running the test again passes.</p>
<p>Small side note: when I ask candidates at interviews to describe TDD they always forget the refactor phase. They remember the part of writing a red test and turning it to green, but nobody mentions the refactoring phase. TDD is not red-green, it's red-green-blue (blue being the refactoring phase).</p>
<p>With that in mind, let's do some refactoring. Not much to improve here, other than show off some of C#'s more recent features like string interpolation:</p>
<p><img class="alignnone size-medium wp-image-2516" src="{{ site.baseurl }}/assets/2017-06-04-16_44_08-greeter-cs-myapp-visual-studio-code.png?w=600" alt="2017-06-04 16_44_08-Greeter.cs - MyApp - Visual Studio Code" width="300" height="223" /></p>
<p>and shorter, expression-bodied methods:</p>
<p><img class="alignnone size-medium wp-image-2520" src="{{ site.baseurl }}/assets/2017-06-04-16_46_00-greeter-cs-myapp-visual-studio-code.png?w=600" alt="2017-06-04 16_46_00-Greeter.cs - MyApp - Visual Studio Code" width="300" height="137" /></p>
<p>and of course rename the <code>v</code> parameter to a more appropriate name, like <code>personToGreet</code> (well anything is better than <code>v</code> in this case).</p>
<p>&nbsp;</p>
